#!/bin/zsh

color_green="\e[0;32m"

cd $1
printf "\nDirectory $color_green'$1'\e[0m is created successfully\n"

# ! Creating file system
mkdir .vscode src src/controllers src/models src/routers src/utils
touch .env .gitignore nodemon.json rome.json src/app.ts src/utils/envConfig.ts

echo '{
  "extensions": [
    {
      "name": "Rome",
      "description": "Rome unifies your development stack by combining the functionality of separate tools. It uses a single configuration file, has fantastic performance, and works with any stack.",
      "version": "0.28.0",
      "category": "Linters",
      "source": "https://marketplace.visualstudio.com/items?itemName=rome.rome"
    }
  ]
}
' > .vscode/recommendations.json

echo '{
    "[javascript]": {
        "editor.defaultFormatter": "rome.rome"
    },
    "[typescript]": {
        "editor.defaultFormatter": "rome.rome"
    },
    "[javascriptreact]": {
        "editor.defaultFormatter": "rome.rome"
    },
    "[typescriptreact]": {
        "editor.defaultFormatter": "rome.rome"
    },
    "cSpell.enableFiletypes": [
        "shellscript"
    ],
}
'> .vscode/settings.json

echo 'DEV_PORT=3000
PROD_PORT=
' >> .env

printf "\n"$color_green"Creating general config...\e[0m\n"

echo '# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test
.vscode/

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
' >> .gitignore

echo '{
  "watch": ["src"],
  "ext": ".ts,.js",
  "ignore": [],
  "exec": "npx ts-node ./src/app.ts"
}
' >> nodemon.json

echo '{
  "$schema": "./node_modules/rome/configuration_schema.json",
  "organizeImports":{
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true
    }
  },
  "formatter" : {
    "enabled": true
  }
}
' >> rome.json

npx tsc --init --outDir dist/ --rootDir src

echo 'import { type Request, type Response } from "express";

const getProduct = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

const getProducts = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

const createProduct = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

const updatePutProduct = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

const updatePatchProduct = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

const deleteProduct = (req: Request, res: Response) => {
	const { method } = req;

	return res
		.status(501)
		.json({ "Status code": 501, Message: `Method ${method} not implemented` });
};

export {
	createProduct,
	deleteProduct,
	getProduct,
	getProducts,
	updatePatchProduct,
	updatePutProduct,
};

' > src/controllers/productController.ts

echo 'export * from "./productController";' > src/controllers/index.ts

echo 'import express ,{ Router } from "express";
import {
	getProducts,
	getProduct,
	createProduct,
	deleteProduct,
	updatePatchProduct,
	updatePutProduct,
} from "../controllers";

const productRoute = Router();
productRoute.use(express.json());

productRoute.get("/", getProducts);

productRoute.get("/id", getProduct);

productRoute.post("/", createProduct);

productRoute.put("/:id", updatePutProduct);

productRoute.patch("/:id", updatePatchProduct);

productRoute.delete("/:id", deleteProduct);

export default productRoute;
' >> src/routers/productRoute.ts

echo 'export { default as productRoute } from "./productRoute";' > src/routers/index.ts

echo 'import dotenv from "dotenv";

dotenv.config();

const config = {
  port: process.env.PROD_PORT || process.env.DEV_PORT,
}

export default config;
' >> src/utils/envConfig.ts

echo 'import express from "express";
import config from "./utils/envConfig";

import { productRoute } from "./routers";

const app = express();

app.use("/api", productRoute);

const PORT = process.env.PROD_PORT || process.env.DEV_PORT;

app.listen(PORT, () => {
	console.log(`Server listen on port ${config.port}...`);
});
' >> src/app.ts
